//
//  FileHandler.swift
//  iBrogueCE_iPad
//
//  Created by Robert Taylor on 4/29/22.
//  Copyright Â© 2022 Seth howard. All rights reserved.
//

import Foundation

void initHighScores() {
    NSMutableArray *scoresArray, *textArray, *datesArray;
    short j, theCount;
    
    if ([[NSUserDefaults standardUserDefaults] arrayForKey:@"high scores scores"] == nil
        || [[NSUserDefaults standardUserDefaults] arrayForKey:@"high scores text"] == nil
        || [[NSUserDefaults standardUserDefaults] arrayForKey:@"high scores dates"] == nil) {
        
        scoresArray = [NSMutableArray arrayWithCapacity:HIGH_SCORES_COUNT];
        textArray = [NSMutableArray arrayWithCapacity:HIGH_SCORES_COUNT];
        datesArray = [NSMutableArray arrayWithCapacity:HIGH_SCORES_COUNT];
        
        for (j=0; j<HIGH_SCORES_COUNT; j++) {
            [scoresArray addObject:[NSNumber numberWithLong:0]];
            [textArray addObject:[NSString string]];
            [datesArray addObject:[NSDate date]];
        }
        
        [[NSUserDefaults standardUserDefaults] setObject:scoresArray forKey:@"high scores scores"];
        [[NSUserDefaults standardUserDefaults] setObject:textArray forKey:@"high scores text"];
        [[NSUserDefaults standardUserDefaults] setObject:datesArray forKey:@"high scores dates"];
    }
    
    theCount = [[[NSUserDefaults standardUserDefaults] arrayForKey:@"high scores scores"] count];
    
    if (theCount < HIGH_SCORES_COUNT) { // backwards compatibility
        scoresArray = [NSMutableArray arrayWithCapacity:HIGH_SCORES_COUNT];
        textArray = [NSMutableArray arrayWithCapacity:HIGH_SCORES_COUNT];
        datesArray = [NSMutableArray arrayWithCapacity:HIGH_SCORES_COUNT];
        
        [scoresArray setArray:[[NSUserDefaults standardUserDefaults] arrayForKey:@"high scores scores"]];
        [textArray setArray:[[NSUserDefaults standardUserDefaults] arrayForKey:@"high scores text"]];
        [datesArray setArray:[[NSUserDefaults standardUserDefaults] arrayForKey:@"high scores dates"]];
        
        for (j=theCount; j<HIGH_SCORES_COUNT; j++) {
            [scoresArray addObject:[NSNumber numberWithLong:0]];
            [textArray addObject:[NSString string]];
            [datesArray addObject:[NSDate date]];
        }
        
        [[NSUserDefaults standardUserDefaults] setObject:scoresArray forKey:@"high scores scores"];
        [[NSUserDefaults standardUserDefaults] setObject:textArray forKey:@"high scores text"];
        [[NSUserDefaults standardUserDefaults] setObject:datesArray forKey:@"high scores dates"];
    }
    
    if ([[NSUserDefaults standardUserDefaults] arrayForKey:@"high scores seeds"] == nil) {
        NSMutableArray *seedArray = [NSMutableArray arrayWithCapacity:HIGH_SCORES_COUNT];
        for (j = 0; j < HIGH_SCORES_COUNT; j++) {
            [seedArray addObject:[NSNumber numberWithInt:0]];
        }
        
        [[NSUserDefaults standardUserDefaults] setObject:seedArray forKey:@"high scores seeds"];
    }
    
    [[NSUserDefaults standardUserDefaults] synchronize];
}

// returns the index number of the most recent score
short getHighScoresList(rogueHighScoresEntry returnList[HIGH_SCORES_COUNT]) {
    NSArray *scoresArray, *textArray, *datesArray;
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    [dateFormatter setDateFormat:@"MM/dd/yy"];
    NSDate *mostRecentDate;
    short i, j, maxIndex, mostRecentIndex;
    long maxScore;
    boolean scoreTaken[HIGH_SCORES_COUNT];
    
    // no scores have been taken
    for (i=0; i<HIGH_SCORES_COUNT; i++) {
        scoreTaken[i] = false;
    }
    
    initHighScores();
    
    scoresArray = [[NSUserDefaults standardUserDefaults] arrayForKey:@"high scores scores"];
    textArray = [[NSUserDefaults standardUserDefaults] arrayForKey:@"high scores text"];
    datesArray = [[NSUserDefaults standardUserDefaults] arrayForKey:@"high scores dates"];
    NSArray *seedArray = [[NSUserDefaults standardUserDefaults] arrayForKey:@"high scores seeds"];
    
    mostRecentDate = [NSDate distantPast];
    
    // store each value in order into returnList
    for (i=0; i<HIGH_SCORES_COUNT; i++) {
        // find the highest value that hasn't already been taken
        maxScore = 0; // excludes scores of zero
        for (j=0; j<HIGH_SCORES_COUNT; j++) {
            if (scoreTaken[j] == false && [[scoresArray objectAtIndex:j] longValue] >= maxScore) {
                maxScore = [[scoresArray objectAtIndex:j] longValue];
                maxIndex = j;
            }
        }
        // maxIndex identifies the highest non-taken score
        scoreTaken[maxIndex] = true;
        returnList[i].score = [[scoresArray objectAtIndex:maxIndex] longValue];
        strcpy(returnList[i].description, [[textArray objectAtIndex:maxIndex] cStringUsingEncoding:NSASCIIStringEncoding]);
        strcpy(returnList[i].date, [[dateFormatter stringFromDate:[datesArray objectAtIndex:maxIndex]] cStringUsingEncoding:NSASCIIStringEncoding]);
        returnList[i].seed = [[seedArray objectAtIndex:maxIndex] longValue];
        
        // if this is the most recent score we've seen so far
        if ([mostRecentDate compare:[datesArray objectAtIndex:maxIndex]] == NSOrderedAscending) {
            mostRecentDate = [datesArray objectAtIndex:maxIndex];
            mostRecentIndex = i;
        }
    }
    
    
    return mostRecentIndex;
}

// saves the high scores entry over the lowest-score entry if it qualifies.
// returns whether the score qualified for the list.
// This function ignores the date passed to it in theEntry and substitutes the current
// date instead.

// TODO: going to assume every save highscore qualifies as an end game screen.

boolean saveHighScore(rogueHighScoresEntry theEntry) {
    NSMutableArray *scoresArray, *textArray, *datesArray;
    NSNumber *newScore;
    NSString *newText;
    
    short j, minIndex = -1;
    long minScore = theEntry.score;
    
    // generate high scores if prefs don't exist or contain no high scores data
    initHighScores();
    
    scoresArray = [NSMutableArray arrayWithCapacity:HIGH_SCORES_COUNT];
    textArray = [NSMutableArray arrayWithCapacity:HIGH_SCORES_COUNT];
    datesArray = [NSMutableArray arrayWithCapacity:HIGH_SCORES_COUNT];
    NSMutableArray *seedArray = [[[NSUserDefaults standardUserDefaults] arrayForKey:@"high scores seeds"] mutableCopy];
    
    [scoresArray setArray:[[NSUserDefaults standardUserDefaults] arrayForKey:@"high scores scores"]];
    [textArray setArray:[[NSUserDefaults standardUserDefaults] arrayForKey:@"high scores text"]];
    [datesArray setArray:[[NSUserDefaults standardUserDefaults] arrayForKey:@"high scores dates"]];
    
    // find the lowest value
    for (j=0; j<HIGH_SCORES_COUNT; j++) {
        if ([[scoresArray objectAtIndex:j] longValue] < minScore) {
            minScore = [[scoresArray objectAtIndex:j] longValue];
            minIndex = j;
        }
    }

//    if (theEntry.score > 0) {
//        [[GameCenterManager sharedInstance] reportScore:theEntry.score forCategory:kBrogueHighScoreLeaderBoard];
//    }
    
    if (minIndex == -1) { // didn't qualify
        return false;
    }
    
    // minIndex identifies the score entry to be replaced
    newScore = [NSNumber numberWithLong:theEntry.score];
    newText = [NSString stringWithCString:theEntry.description encoding:NSASCIIStringEncoding];
    NSNumber *seed = [NSNumber numberWithLong:theEntry.seed];
    
    [scoresArray replaceObjectAtIndex:minIndex withObject:newScore];
    [textArray replaceObjectAtIndex:minIndex withObject:newText];
    [datesArray replaceObjectAtIndex:minIndex withObject:[NSDate date]];
    [seedArray replaceObjectAtIndex:minIndex withObject:seed];
    
    [[NSUserDefaults standardUserDefaults] setObject:scoresArray forKey:@"high scores scores"];
    [[NSUserDefaults standardUserDefaults] setObject:textArray forKey:@"high scores text"];
    [[NSUserDefaults standardUserDefaults] setObject:datesArray forKey:@"high scores dates"];
    [[NSUserDefaults standardUserDefaults] setObject:seedArray forKey:@"high scores seeds"];
    [[NSUserDefaults standardUserDefaults] synchronize];
    
    return true;
}

void initializeLaunchArguments(enum NGCommands *command, char *path, unsigned long *seed) {
    //*command = NG_SCUM;
    *command = NG_NOTHING;
    path[0] = '\0';
    *seed = 0;
}



//void initializeBrogueSaveLocation() {
//    migrateFilesFromLegacyStorageLocation();
//
//    NSFileManager *manager = [NSFileManager defaultManager];
//    NSError *err;
//
//    // Look up the full path to the user's Application Support folder (usually ~/Library/Application Support/).
//    NSString *basePath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex: 0];
//
//    // Use a folder under Application Support named after the application.
//  //  NSString *appName = [[NSBundle mainBundle] objectForInfoDictionaryKey: @"CFBundleName"];
//    NSString *documentsPath = basePath;//[basePath stringByAppendingPathComponent: appName];
//
//    // Create our folder the first time it is needed.
//    if (![manager fileExistsAtPath:documentsPath]) {
//        [manager createDirectoryAtPath:documentsPath withIntermediateDirectories:YES attributes:nil error:&err];
//    }
//
//    // Set the working directory to this path, so that savegames and recordings will be stored here.
//    [manager changeCurrentDirectoryPath:documentsPath];
//}

func initializeBrogueSaveLocation() -> Void {
    _ = try! FileManager.default.url(for: .applicationSupportDirectory, in: .userDomainMask, appropriateFor: nil, create: true)
}


func listFiles(fileCount: inout Short, dynamicMemoryBuffer: inout UnsafeMutablePointer<CChar> ) -> UnsafeMutablePointer<fileEntry> {
    let testType = UnsafeMutablePointer<fileEntry>.allocate(capacity: 1)
    print(type(of: testType))
    
    let fileManager = FileManager()
        
    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "MM/dd/yy"
    
    var fileDictionary: [String:String]
    
    // get all files in the Application Support Directory
    do {
        let applicationSupportDirectoryURL = try fileManager.url(for: .applicationSupportDirectory, in: .userDomainMask, appropriateFor: nil, create: true)
        
        let files = try fileManager.contentsOfDirectory(at: applicationSupportDirectoryURL,
                                                                includingPropertiesForKeys: nil,
                                                                options: [.skipsHiddenFiles,.skipsSubdirectoryDescendants,.includesDirectoriesPostOrder])
        fileCount = Short(files.count)
        for file in files {
            let attributes = try fileManager.attributesOfItem(atPath: file.path)
            let modDate = attributes[.modificationDate]
            fileDictionary[file.path] = dateFormatter.string(from: modDate as! Date)
        }
    } catch {
        // TODO : errors in the file primitives
    }

    // we have files and mod dates in a dictionary, now we need to lay them out for the C buffer
    // and convert it all to UnSafe stuff ... Herre be Dragyons
    // can't reallocate memory in Swift to expand the buffer, so allocate a large buffer to start
    // we've got room, what's 100K bytes among friends?
    
    let buf = UnsafeMutablePointer<CChar>.allocate(capacity: Int(fileCount) * 1024)
    let fileList = UnsafeMutablePointer<fileEntry>.allocate(capacity: Int(fileCount))
    
    var bufOffset=UnsafeMutablePointer<CChar>.init(buf)
    var entry = 0
    
    for file in fileDictionary {
        // key is the pathname, it gets copied into the buffer
        strcpy(buf,(file.key as NSString).utf8String)
        // value is the date, it gets added to a fileEntry
        //fileList[entry].date = (file.value as NSString).utf8String
        let cDate = file.value.data(using: .utf8)
        strncpy(fileList[entry].date, cDate ,8)
        fileList[entry].path = bufOffset
        bufOffset += strlen(file.key)
    }
}


//
//
//#define ADD_FAKE_PADDING_FILES 0
//
//// Returns a malloc'ed fileEntry array, and puts the file count into *fileCount.
//// Also returns a pointer to the memory that holds the file names, so that it can also
//// be freed afterward.
//fileEntry *listFiles(short *fileCount, char **dynamicMemoryBuffer) {
//    short i, count, thisFileNameLength;
//    unsigned long bufferPosition, bufferSize;
//    unsigned long *offsets;
//    fileEntry *fileList;
//    NSMutableArray *array;
//    NSFileManager *manager = [NSFileManager defaultManager];
//    NSError *err;
//    NSDictionary *fileAttributes;
//    NSDateFormatter *dateFormatter;
//    const char *thisFileName;
//
//    char tempString[500];
//
//    bufferPosition = bufferSize = 0;
//    *dynamicMemoryBuffer = NULL;
//
//    dateFormatter = [[NSDateFormatter alloc] init];
//    [dateFormatter setDateFormat:@"MM/dd/yy"];//                initWithDateFormat:@"%1m/%1d/%y" allowNaturalLanguage:YES];
//
//    array = [[manager contentsOfDirectoryAtPath:[manager currentDirectoryPath]  error:&err] mutableCopy];
//    count = [array count];
//
//    //BOOL ascending = YES;
//
//    // sort by creation date
//    NSMutableArray* filesAndProperties = [NSMutableArray arrayWithCapacity:[array count]];
//
//    for(NSString* file in array) {
//
//        if (![file isEqualToString:@".DS_Store"]) {
//            NSString* filePath = [[manager currentDirectoryPath] stringByAppendingPathComponent:file];
//            NSDictionary* properties = [[NSFileManager defaultManager]
//                                        attributesOfItemAtPath:filePath
//                                        error:&err];
//            NSDate* modDate = [properties objectForKey:NSFileModificationDate];
//
//            [filesAndProperties addObject:[NSDictionary dictionaryWithObjectsAndKeys:
//                                           file, @"path",
//                                           modDate, @"lastModDate",
//                                           nil]];
//
//        }
//    }
//
//    // Sort using a block - order inverted as we want latest date first
//    NSArray* sortedFiles = [filesAndProperties sortedArrayUsingComparator:
//                            ^(id path1, id path2)
//                            {
//                                // compare
//                                NSComparisonResult comp = [[path1 objectForKey:@"lastModDate"] compare:
//                                                           [path2 objectForKey:@"lastModDate"]];
//                                // invert ordering
//                                if (comp == NSOrderedDescending) {
//                                    comp = NSOrderedAscending;
//                                }
//                                else if(comp == NSOrderedAscending){
//                                    comp = NSOrderedDescending;
//                                }
//                                return comp;
//                            }];
//
//
//    [array removeAllObjects];
//    for(NSDictionary* dict in sortedFiles) {
//        [array addObject:[dict objectForKey:@"path"]];
//    }
//
//    fileList = (fileEntry *)malloc((count + ADD_FAKE_PADDING_FILES) * sizeof(fileEntry));
//    offsets = (unsigned long*)malloc((count + ADD_FAKE_PADDING_FILES) * sizeof(unsigned long));
//
//    for (i=0; i < count + ADD_FAKE_PADDING_FILES; i++) {
//        if (i < count) {
//            thisFileName = [[array objectAtIndex:i] cStringUsingEncoding:NSASCIIStringEncoding];
//            fileAttributes = [manager attributesOfItemAtPath:[array objectAtIndex:i] error:nil];
//
//            NSString *aDate = [dateFormatter stringFromDate:[fileAttributes fileModificationDate]];
//
//            const char *date = [aDate cStringUsingEncoding:NSASCIIStringEncoding];
//
//            strcpy(fileList[i].date,
//                   date);
//        } else {
//            // Debug feature.
//            sprintf(tempString, "Fake padding file %i.broguerec", i - count + 1);
//            thisFileName = &(tempString[0]);
//            strcpy(fileList[i].date, "12/12/12");
//        }
//
//        thisFileNameLength = strlen(thisFileName);
//
//        if (thisFileNameLength + bufferPosition > bufferSize) {
//            bufferSize += sizeof(char) * 1024;
//            *dynamicMemoryBuffer = (char *) realloc(*dynamicMemoryBuffer, bufferSize);
//        }
//
//        offsets[i] = bufferPosition; // Have to store these as offsets instead of pointers, as realloc could invalidate pointers.
//
//        strcpy(&((*dynamicMemoryBuffer)[bufferPosition]), thisFileName);
//        bufferPosition += thisFileNameLength + 1;
//    }
//
//    // Convert the offsets to pointers.
//    for (i = 0; i < count + ADD_FAKE_PADDING_FILES; i++) {
//        fileList[i].path = &((*dynamicMemoryBuffer)[offsets[i]]);
//    }
//
//    free(offsets);
//
//    *fileCount = count + ADD_FAKE_PADDING_FILES;
//    return fileList;
//}
